"""
PJSIP Configuration Generator
"""
import os
import logging
import subprocess
import urllib.request
import socket
from typing import List
from database import SIPPeer, SIPTrunk
from version import VERSION

logger = logging.getLogger(__name__)

PJSIP_CONFIG_PATH = "/etc/asterisk/custom/pjsip.conf"


def _detect_external_ip() -> str:
    """Auto-detect external IP if not set via environment variable."""
    env_ip = os.getenv("EXTERNAL_IP", "").strip()
    if env_ip:
        return env_ip

    # Try public IP detection services
    for url in ["https://api.ipify.org", "https://ifconfig.me/ip", "https://icanhazip.com"]:
        try:
            resp = urllib.request.urlopen(url, timeout=3)
            ip = resp.read().decode().strip()
            if ip:
                logger.info(f"Auto-detected external IP: {ip}")
                return ip
        except Exception:
            continue

    # Fallback: get default route IP
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        ip = s.getsockname()[0]
        s.close()
        if ip and ip != "127.0.0.1":
            logger.info(f"Using local IP as fallback: {ip}")
            return ip
    except Exception:
        pass

    logger.warning("Could not detect external IP - using 127.0.0.1, SIP audio will NOT work!")
    return "127.0.0.1"


EXTERNAL_IP = _detect_external_ip()
SIP_PORT = os.getenv("SIP_PORT", "5060")

DEFAULT_CODECS = "ulaw,alaw,g722,opus"


def generate_pjsip_config(peers: List[SIPPeer], global_codecs: str = DEFAULT_CODECS, acl_enabled: bool = False) -> str:
    """Generate complete pjsip.conf content"""

    # Build allow lines from global codecs
    codec_list = [c.strip() for c in global_codecs.split(",") if c.strip()]
    allow_lines = "\n".join(f"allow={c}" for c in codec_list)
    acl_line = "\nacl=registration-whitelist" if acl_enabled else ""

    config = f"""; Auto-generated PJSIP configuration
; Generated by Asterisk PBX GUI

[global]
type=global
max_forwards=70
user_agent=GonoPBX {VERSION}

[transport-udp]
type=transport
protocol=udp
bind=0.0.0.0:5060
external_media_address={EXTERNAL_IP}
external_signaling_address={EXTERNAL_IP}
external_signaling_port={SIP_PORT}
local_net=172.0.0.0/8
local_net=10.0.0.0/8
local_net=192.168.0.0/16

[transport-tcp]
type=transport
protocol=tcp
bind=0.0.0.0:5060

[endpoint-basic](!)
type=endpoint
context=internal
language=de
disallow=all
{allow_lines}
direct_media=no
rtp_symmetric=yes
force_rport=yes
rewrite_contact=yes
ice_support=yes{acl_line}

[auth-basic](!)
type=auth
auth_type=userpass

[aor-basic](!)
type=aor
max_contacts=5
remove_existing=yes
qualify_frequency=60

; === Peers ===
"""

    for peer in peers:
        if peer.enabled:
            # Per-peer codec override
            peer_codec_lines = ""
            if peer.codecs:
                peer_codecs = [c.strip() for c in peer.codecs.split(",") if c.strip()]
                peer_codec_lines = "\ndisallow=all\n" + "\n".join(f"allow={c}" for c in peer_codecs)

            config += f"""
[{peer.extension}](endpoint-basic)
auth=auth{peer.extension}
aors={peer.extension}
callerid="{peer.caller_id or peer.extension}" <{peer.extension}>{peer_codec_lines}

[auth{peer.extension}](auth-basic)
username={peer.extension}
password={peer.secret}

[{peer.extension}](aor-basic)
"""

    return config


def generate_trunk_config(trunk: SIPTrunk, skip_identify: bool = False) -> str:
    """Generate PJSIP config section for a single SIP trunk.
    skip_identify: if True, omit the identify section (another trunk already matches this server)
    """
    tid = trunk.id
    config = f"\n; --- Trunk: {trunk.name} (ID {tid}) ---\n"

    if trunk.auth_mode == "registration":
        config += f"""
[trunk-{tid}]
type=registration
outbound_auth=trunk-auth-{tid}
server_uri=sip:{trunk.sip_server}
client_uri=sip:{trunk.username}@{trunk.sip_server}
contact_user={trunk.username}

[trunk-ep-{tid}]
type=endpoint
outbound_auth=trunk-auth-{tid}
aors=trunk-aor-{tid}
context={trunk.context}
language=de
from_domain={trunk.sip_server}
disallow=all
allow={trunk.codecs}
direct_media=no
rtp_symmetric=yes
force_rport=yes
rewrite_contact=yes

[trunk-auth-{tid}]
type=auth
auth_type=userpass
username={trunk.username}
password={trunk.password}

[trunk-aor-{tid}]
type=aor
contact=sip:{trunk.sip_server}
qualify_frequency=60
"""
    else:
        # IP-based auth (no registration, no auth block)
        config += f"""
[trunk-ep-{tid}]
type=endpoint
aors=trunk-aor-{tid}
context={trunk.context}
language=de
from_domain={trunk.sip_server}
disallow=all
allow={trunk.codecs}
direct_media=no
rtp_symmetric=yes
force_rport=yes
rewrite_contact=yes

[trunk-aor-{tid}]
type=aor
contact=sip:{trunk.sip_server}
qualify_frequency=60
"""

    if not skip_identify:
        config += f"""[trunk-identify-{tid}]
type=identify
endpoint=trunk-ep-{tid}
match={trunk.sip_server}
"""
    else:
        config += f"; identify skipped - shared with another trunk on {trunk.sip_server}\n"

    return config

    return config


def write_pjsip_config(peers: List[SIPPeer], trunks: List[SIPTrunk] = None, global_codecs: str = DEFAULT_CODECS, acl_enabled: bool = False) -> bool:
    """Write PJSIP config to file"""
    try:
        config_content = generate_pjsip_config(peers, global_codecs, acl_enabled=acl_enabled)

        if trunks:
            config_content += "\n; === SIP Trunks ===\n"
            # Track which SIP servers already have an identify section
            # to avoid duplicate matches (multiple trunks from same provider)
            seen_servers: set = set()
            for trunk in trunks:
                if trunk.enabled:
                    config_content += generate_trunk_config(trunk, skip_identify=trunk.sip_server in seen_servers)
                    seen_servers.add(trunk.sip_server)

        os.makedirs(os.path.dirname(PJSIP_CONFIG_PATH), exist_ok=True)

        with open(PJSIP_CONFIG_PATH, 'w') as f:
            f.write(config_content)

        logger.info(f"PJSIP config written with {len(peers)} peers, {len(trunks or [])} trunks")
        return True

    except Exception as e:
        logger.error(f"Failed to write PJSIP config: {e}")
        return False

def reload_asterisk() -> bool:
    """Reload Asterisk PJSIP - copy config inside Asterisk container"""
    try:
        # Kopiere die Config IM Asterisk-Container (nicht vom Backend aus)
        result = subprocess.run(
            ['docker', 'exec', 'pbx_asterisk', 'sh', '-c',
             'cp /etc/asterisk/custom/pjsip.conf /etc/asterisk/pjsip.conf && asterisk -rx "pjsip reload"'],
            capture_output=True,
            text=True,
            timeout=10
        )

        if result.returncode == 0:
            logger.info(f"Asterisk reloaded successfully")
            return True
        else:
            logger.error(f"Reload failed: {result.stderr}")
            return False

    except Exception as e:
        logger.error(f"Failed to reload: {e}")
        return False
